package sssa

import (
	"testing"
)

func TestCreateCombine(t *testing.T) {
	// Short, medium, and long tests
	strings := []string{
		"N17FigASkL6p1EOgJhRaIquQLGvYV0",
		"0y10VAfmyH7GLQY6QccCSLKJi8iFgpcSBTLyYOGbiYPqOpStAf1OYuzEBzZR",
		"KjRHO1nHmIDidf6fKvsiXWcTqNYo2U9U8juO94EHXVqgearRISTQe0zAjkeUYYBvtcB8VWzZHYm6ktMlhOXXCfRFhbJzBUsXaHb5UDQAvs2GKy6yq0mnp8gCj98ksDlUultqygybYyHvjqR7D7EAWIKPKUVz4of8OzSjZlYg7YtCUMYhwQDryESiYabFID1PKBfKn5WSGgJBIsDw5g2HB2AqC1r3K8GboDN616Swo6qjvSFbseeETCYDB3ikS7uiK67ErIULNqVjf7IKoOaooEhQACmZ5HdWpr34tstg18rO",
	}

	minimum := []int{4, 6, 20}
	shares := []int{5, 100, 100}

	for i := range strings {
		if Combine(Create(minimum[i], shares[i], strings[i])) != strings[i] {
			t.Fatal("Fatal: creating and combining returned invalid data")
		}
	}
}

func TestLibraryCombine(t *testing.T) {
	shares := []string{
		"jO_ttqvPQsQlHMHNks4wqKmhQqcFwyRALtHgife6Bx66p7azBbFway_wMwbT90KI2re7Hq3noZmO6BSfph3-Gg",
		"qh74wE3z6MgNPhnCugXEfq89D0yrJjJS25Mc3BiGt4Igsz8SYu7Rb9xPVMwT1yvpTV1S-PBLnAhQt4Ge7xta6A",
		"tlNQjjrjEoXWgNqENm-_mV-QfaS8IoiEQ6VszAuWwaz67YGvO8efkJ098ZOlCvIoiymvS5Va9ZrV0oITkrLBoQ",
	}

	if Combine(shares) != "test-pass" {
		t.Fatal("Failed library cross-language check")
	}
}

func TestIsValidShare(t *testing.T) {
	shares := [][]byte{

		[]byte{0xaa, 0x5e, 0xcd, 0xec, 0x6c, 0xaa, 0xd1, 0xdf,
			0x46, 0x99, 0xb4, 0xc4, 0x40, 0xc3, 0x28, 0x21,
			0x09, 0x63, 0x41, 0x69, 0x0d, 0x0a, 0xd8, 0xbe,
			0x0a, 0x8e, 0x7c, 0x28, 0xe2, 0x29, 0xc3, 0x72,
			0x2c, 0x96, 0xab, 0x00, 0xa8, 0x7b, 0x04, 0x7e,
			0xe1, 0xaf, 0x2b, 0x23, 0x1b, 0xa6, 0x53, 0xdb,
			0x20, 0x8e, 0xdc, 0xdc, 0x92, 0xc9, 0xc8, 0x3e,
			0x9c, 0x8b, 0xa4, 0x8c, 0x56, 0xd6, 0xf7, 0xc5},

		// just barely works
		[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43},

		// one too big barely works
		[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x44,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x43},
	}

	results := []bool{
		true,
		true,
		false,
	}

	for i := range shares {
		if IsValidShare(shares[i]) != results[i] {
			t.Fatal("Checking for valid shares failed:", i)
		}
	}
}
